{
  "name": "queue",
  "version": "2.2.0",
  "description": "async job queue with adjustable concurrency",
  "repository": {
    "type": "git",
    "url": "https://github.com/jessetane/queue.git"
  },
  "dependencies": {
    "inherits": "~2.0.0"
  },
  "devDependencies": {
    "tape": "*"
  },
  "scripts": {
    "test": "node test",
    "example": "node example"
  },
  "testling": {
    "files": "test/index.js",
    "browsers": [
      "ie/8..latest",
      "ff/25..latest",
      "chrome/25..latest",
      "safari/5.1..latest",
      "opera/12..latest"
    ]
  },
  "author": {
    "name": "Jesse Tane",
    "email": "jesse.tane@gmail.com"
  },
  "license": "WTFPL",
  "readme": "```\n   ____ ___  _____  __  _____ \n  / __ `/ / / / _ \\/ / / / _ \\\n / /_/ / /_/ /  __/ /_/ /  __/\n \\__, /\\__,_/\\___/\\__,_/\\___/ \n   /_/                        \n```\nasync job queue with adjustable concurrency\n\n[![browser support](http://ci.testling.com/jessetane/queue.png)](http://ci.testling.com/jessetane/queue)\n\n## why\nwanted something more flexible than [async](https://github.com/caolan/async#queue)'s queue\n\n## how\nthe module exports a class `Queue` that implements most of the `Array` api. pass async functions (ones that accept a callback) to an instance's additive array methods. processing begins when you call `q.start()`\n\n## api\n* `start()`  \n* `stop()`  \n* `end([err])` stop and empty the queue immediately\n\ninherited from `Array`:\n* `push(element1, ..., elementN)`  \n* `unshift(element1, ..., elementN)`  \n* `splice(index , howMany[, element1[, ...[, elementN]]])`  \n* `pop()`  \n* `shift()`  \n* `slice(begin[, end])`  \n* `reverse()`  \n* `indexOf(searchElement[, fromIndex])`  \n* `lastIndexOf(searchElement[, fromIndex])`  \n\n## properties\n* `concurrency` maximum number of jobs that the queue should process concurrently - the default is 1  \n* `timeout` milliseconds to wait for a job to execute its callback  \n* `length` jobs pending + jobs to process (readonly)\n\n## events\n* `q.emit('success', result, job)` after a job executes its callback  \n* `q.emit('error', err, job)` after a job passes an error to its callback  \n* `q.emit('timeout', continue, job)` after `q.timeout` milliseconds have elapsed and a job has not executed its callback  \n* `q.emit('end'[, err])` after all jobs have been processed\n\n## download\n`npm install queue`  \n\n## tests\n`node test`\n\n## example\n`node example` runs this:\n```javascript\nvar queue = require('queue');\n\nvar q = queue({\n  timeout: 100,\n  concurrency: 100\n});\n\nvar results = [];\n\n\n// listen for events\n\nq.on('success', function(result, job) {\n  console.log('job finished processing:', job.toString().replace(/\\n/g, ''));\n});\n\nq.on('end', function() {\n  console.log('all done:', results);\n});\n\n\n// add jobs using the familiar Array API\n\nq.push(function(cb) {\n  results.push('two');\n  cb();\n});\n\nq.push(\n  function(cb) {\n    results.push('four');\n    cb();\n  },\n  function(cb) {\n    results.push('five');\n    cb();\n  }\n);\n\nq.unshift(function(cb) {\n  results.push('one');\n  cb();\n});\n\nq.splice(2, 0, function(cb) {\n  results.push('three');\n  cb();\n});\n\n\n// use the timeout feature to deal with jobs that \n// take too long or forget to execute a callback\n\nq.on('timeout', function(next, job) {\n  console.log('job timed out:', job.toString().replace(/\\n/g, ''));\n  next();\n});\n\nq.push(function(cb) {\n  setTimeout(function() {\n    console.log('slow job finished');\n    cb();\n  }, 200);\n});\n\nq.push(function(cb) {\n  console.log('forgot to execute callback');\n});\n\nq.start();\n```\n\n## note\nversion 2.0 introduces api changes and is not backwards compatible with 1.0\n\n## license\nWTFPL\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jessetane/queue/issues"
  },
  "homepage": "https://github.com/jessetane/queue",
  "_id": "queue@2.2.0",
  "_from": "queue@~2.2.0"
}
